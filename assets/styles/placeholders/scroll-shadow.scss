@use "../base/functions" as func;

/**
* Add shadows to an element that can scroll but only when the scrolling would
* be necessary to see the rest of the content.
*
* How to use
* ----------
*
* - Extend %p-scroll-shadow, %p-scroll-shadow-v, or %p-scroll-shadow-h.
* - Optionally set `--p-scroll-shadow-colour` and/or `--p-scroll-shadow-size`.
*
* How to works
* ------------
*
* The trick is the combination of the "p-scroll-shadow" @keyframes and the
* `scroll()` function being set as `animation-timeline`. This gives the effect
* of converting a number (`p-scroll-shadow-scroll`) from 0 to 1, depending on
* how much of the scrolling has occurred. We use that as a multiplier for
* background positioning, moving the shadows into and out of view.
*
* The second trick is that the background colour is
* `--p-scroll-shadow-real-colour` and that's only set in the @keyframes.
* Technically the shadows are always present, but because they're transparent
* unless the `scroll()` function can trigger (which only works if there's any
* scrolling possible) it creates the illusion of shadows only appearing when
* the element has the ability to scroll.
*
* Known issues
* ------------
*
* 1.
* At time of writing (2025-04-28), Firefox only understands the `scroll()`
* function if enabled by a flag. This means that the shadow probably won't
* appear in Firefox.
*
* 2.
* The background position can't use the logical directions, so combining this
* with `writing-mode: vertical-lr` might create strange effects.
*
* Author: https://stackoverflow.com/a/79136430/557019
*/

@property --p-scroll-shadow-angle { syntax: "<angle>"; initial-value: 0; inherits: true; }
@property --p-scroll-shadow-colour { syntax: "<color>"; initial-value: currentColor; inherits: true; }
@property --p-scroll-shadow-real-colour { syntax: "<color>"; initial-value: transparent; inherits: true; }
@property --p-scroll-shadow-size { syntax: "<length-percentage>"; initial-value: #{func.get-sizing-pixels-unit("base-sizing")}; inherits: true; }
@property --p-scroll-shadow-scroll { syntax: "<number>"; initial-value: 0; inherits: true; }

@keyframes p-scroll-shadow {
    from,
    to {
        --p-scroll-shadow-real-colour: var(--p-scroll-shadow-colour);
    }
    to {
        --p-scroll-shadow-scroll: 1;
    }
}

%p-scroll-shadow,
%p-scroll-shadow-v,
%p-scroll-shadow-h,
.p-scroll-shadow,
.p-scroll-shadow-v,
.p-scroll-shadow-h {
    --p-scroll-shadow-angle: 0;
    --p-scroll-shadow-colour: rgb(from currentColor r g b / 20%);
    --p-scroll-shadow-size: var(--base-sizing);

    animation: p-scroll-shadow cubic-bezier(.25,.85,.8,.22);
    animation-timeline: scroll(self);
    animation-range: 0 100%;
    background-image: linear-gradient(
        var(--p-scroll-shadow-angle),
        var(--p-scroll-shadow-real-colour) 0%,
        transparent calc((var(--p-scroll-shadow-scroll)) * var(--p-scroll-shadow-size)),
        transparent calc(100% - var(--p-scroll-shadow-size) * (1 - var(--p-scroll-shadow-scroll))),
        var(--p-scroll-shadow-real-colour) 100%
    );
}

%p-scroll-shadow-h,
.p-scroll-shadow-h {
    --p-scroll-shadow-angle: 90deg;
    animation-timeline: scroll(self inline);
}
